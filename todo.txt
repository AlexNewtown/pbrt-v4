
GFX!

- implement improved delta/ratio tracking stuff...

- explicit path representation (review mitsuba libbidir stuff). Also, just
  build on top of bdpt Vertex stuff (or generalize, and build both on top?)

- support animated light sources (transformation at least)

- light tree for many lights
  - split two sided lights into two light sources, for better light tree
    culling?
  
- revisit materials, mitsuba style

- Direct lighting: does it make sense to run this for specular bsdf
  components as well (and not sample the light, obviously), and then just
  always ignore emission after the very first intersection?
  - actually, the opposite---never sample the bsdf in direct lighting code,
    then always incorportate (and MIS) at intersections

- implement filter importance sampling

- BDPT RR

- BDPT: do standard MIS direct lighting at end (and then can use fancy
  light sampling stuff)

-----------------

- use Bilerp() for texture filtering, other places?

- paramset unit tests, especially shadowing stuff
  ParamSet -> ParameterSet
  TextureParams -> ...?
  why doesn't everyone just take a TextureParams, make ParamSet an
    implementation detail of it?  ScopedParameters? ...?
    doesn't make sense for film to take textures? or is that what we should
    do to e.g. specify light emissing stuff. then tabularize if procedural?
    etc..
  
- be more consistent to not do error checking during pbrt cat and to ply

+ inconsistent: RenderOptions::MakeIntegrator vs e.g. standalone MakeFilter

- merge in segment tree stuff, add tests
  - double-buffer; can threads update their own and then periodically merge?

- could nuke worldbegin/worldend entirely--not at all relevant to us...

- Waverfront based stuff.  Make optional, only do if writing out
  intermediate images, or.... ?  Or is this too much complexity in the main
  render loop??

- code organization:
  base/{camera,shape,light,...}
  sampling/...
  core/paramset, api, parse,
  scattering: reflection, phase function implementations
  or is that too much decomposition for core/?
  - why is error.* in core?

base/
camera.h
filter.h
integrator.h
light.h
material.h
medium.h
primitive.h
sampler.h
shape.h
texture.h
bssrdf.h (some)
reflection.h (some)

scattering/
bssrdf.h (some)
reflection.h (some), break apart?
microfacet.h

core/
pbrt.h
api.h
paramset.h
parser.h
pbrtparse.h
scene.h
film.h
error.h -> util? (or here because uses context from parsing--file, line no?) 
? core/
texcache.h
spectrum.h
image.h -> util ?
interaction.h
lightdistrib.h
mipmap.h

sampling/
lowdiscrepancy.h
sampling.h
sobolmatrices.h
much break apart? shapes.h, ... ?

- add more simple volume scattering tests--verious light types, etc.
  light in medium, light not in medium, camera in/out, etc.

- camera autofocus functionality

- failures from run with debug checks:
  splash.pbrt, plume-volpath, transparent machines/frame1266: compute differentials NaN for scattering 

- provide an option for blinear sampling Distribution2D
  - option for Distribution1D to sample linear? Or separate class?
    Constant1dDistribution
    Linear1dDistribution
    ... ?

--onesample x,y,samp (+ enough logging to chase it down)

- move Light::Le() into infinitearealight only?
  Light -> InfiniteLight -> InfiniteImageLight ?

- camera space experiments (all done at the API level?)

- tests for light * -> pdf computaiton

- use SampleDiscrete
  - BSDF component sampling? (can we generalize the glass dual lobe stuff?)
  - light tree (eventually)
  - other binary sampling decisions?

- crash in bvh build for curly hair (on mac).

- more tests for bdpt, volumes, ...

- more mathutil tests..

- find places to use CHECK_RARE (microfacet, bsdf evaluations?)

- feel like we want a separate Sampler instance for volume stuff. on very first
  shadow ray, Scene::IntersectTr() may use dimensions, which messes up
  all subsequent dimensions...

- absl:
  container/inlined_vector.h: InlinedVector, in particular for
    Distribution1D stuff

- rename GonioPhotometricLight -> GoniometricLight?

- avx2 check https://gist.github.com/UnaNancyOwen/263c243ae1e05a2f9d0e

- RGB class? (eventually records primaries, etc.)

- Image::SetRGB method? Spectrum in general is sort of out of place, since
  we're explicit about "this is a 3 channel image", etc...
  - but otoh we do want to someday support spectral Images...

- avx 2 support, half to float, etc...  -march=native?

- ToString(), etc:
  BSSRDF
  Camera
  EFloat
  Film, FilmTile
  Filter
  fp16
  Image
  Integrator
  Interaction
  Light
  LightDistribution
  Material
  MIPMap
  ParamSetItem (refactor from ParamSet ToString())
  Primitive
  Sampler
  Scene
  Shape
  TextureMapping*

- find interval test is broken

- pbrtAttribute: use attributes for parameter initialization backup...  can
  we pass something to the Create functions that helps abstract this?

- Scene::ForEachLight, Shape(bool expandInstances), Material, ... ?

- std::string_view (in many places) (absl equivalent?)

- time reported by profiling system vs progress reporter (and reported in
  stats) doesn't match... (only for short renders? need more investigation)

- remove black filtering mode?

- use kahan summation for accumulating into the image, not for accumulating
  into the tile!!!
  
- add test for elementary intervals on e.g. sobol arrays, just to be sure
  the array sampling isn't borked

- figure out consistent merging of film tiles so have fully deterministic
  final pixel outputs
  
- api.cpp: Create* vs Make*, etc.

- api / MakeFilter error handling (exit) is inconsistent with others...
  General API error handling review. Recover and use something, or fail
  hard?
  
- test alpha tex for non triangles. also review how it's passed through for
  non-triangles in --cat/--toply

- what does an alpha'ed out area light mean, anyway? not visible to eye,
  visible to e.g. diffuse reflection, what about specular? glossy? for
  specular, does it make a difference if there's a transparent plane
  between the viewer and the light? why should it? consistency here is
  tricky...

- params faceindices face_indices faceIndices

- alpha masking really doesn't work with area lights (do we care, or is
  this just for leaves?)
    - nuke shadowalpha: alpha can be made physical, not shadow...
   + render san miguels to see if it matters...

- do we actually use tHit at this point? (for anything besides far hit culling)

- how come e.g. a triangle isn't xformed twice when an area light source?
  light to world versus the baked in world space xform
  
- IntersectTr? only used once?

- move ray into its own header?

- texcache branch is blurring bump map lookups; see e.g. bump-sphere.pbrt.
  do side-by-side runs?  this is due to bilerp default (only partly?)

- actually do robust bvh traversal--watertight...

- manuka-style pre-dice?

- BxDFType is really only used for "was it specular" at this point;
  simplify?  (BSSRDFs also though...)

- pass relative IOR rather than both IORs everywhere that's possible. be
  consistent: to/from, right? 

- FindOneFilename: support search path. also, pass it in (absl-based?)

- break out cat and toply to be separate (C++) implementations of the API,
  such that we can run it on individual files, w/o worrying about am I in a
  world block, etc...

- v3->v4 upgrade option  (cat variant)

- rename --cat to --fmt ?
